<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>머신러닝 퀴즈</title>
  <style>
    :root { --bg:#fafafa; --card:#fff; --ink:#111; --muted:#6b7280; --line:#e5e7eb; --ok:#065f46; --okbg:#ecfdf5; --bad:#991b1b; --badbg:#fef2f2; }
    * { box-sizing: border-box; }
    body { margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Noto Sans KR, Apple SD Gothic Neo, "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans", sans-serif; background:var(--bg); color:var(--ink); }
    header { position:sticky; top:0; z-index:10; background:rgba(255,255,255,.9); backdrop-filter:saturate(180%) blur(10px); border-bottom:1px solid var(--line); }
    .wrap { max-width: 820px; margin: 0 auto; padding: 16px; }
    h1 { font-size: 22px; margin: 8px 0; }
    .row { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    button, .btn { appearance:none; border:1px solid var(--line); background:#fff; padding:8px 12px; border-radius:12px; cursor:pointer; }
    button.primary { background:#111; color:#fff; }
    button:hover, .btn:hover { background:#f5f5f5; }
    main { padding:16px; }
    .card { background:var(--card); border:1px solid var(--line); border-radius:16px; box-shadow: 0 1px 3px rgba(0,0,0,.04); padding:16px; }
    .muted { color: var(--muted); font-size: 14px; }
    .q { margin: 0 0 8px; font-weight: 600; }
    textarea, select, input[type="text"] { width:100%; padding:10px 12px; border:1px solid var(--line); border-radius:12px; background:#fff; }
    ol { list-style: none; padding:0; margin:0; }
    li + li { margin-top: 12px; }
    .badge { font-size:12px; padding:4px 8px; border-radius:8px; border:1px solid transparent; }
    .badge.ok { color:var(--ok); background:var(--okbg); border-color:#a7f3d0; }
    .badge.bad { color:var(--bad); background:var(--badbg); border-color:#fecaca; }
    details { margin-top:8px; }
    summary { cursor:pointer; }
    code { background:#f3f4f6; padding:2px 6px; border-radius:6px; }
    footer { color:var(--muted); font-size:12px; margin: 32px 0 16px; }
    .grid { display:grid; grid-template-columns: 1fr; gap:12px; }
    @media (min-width: 640px){ .grid { grid-template-columns: 1fr 1fr; } }
  </style>
</head>
<body>
  <header>
    <div class="wrap row" style="justify-content:space-between;">
      <h1>📝 머신러닝 핵심 퀴즈</h1>
      <div class="row">
        <button id="btnDefault" class="btn">기본 세트</button>
      </div>
    </div>
  </header>

  <main class="wrap">
    <section id="stats" class="card" aria-live="polite">
      <div class="grid">
        <div>
          <div class="muted">문항 수</div>
          <div id="count" style="font-weight:600;">-</div>
        </div>
        <div>
          <div class="muted">채점 완료</div>
          <div id="graded" style="font-weight:600;">-</div>
        </div>
      </div>
      <div class="row" style="margin-top:10px;">
        <button id="btnGradeAll" class="primary">전체 채점</button>
        <button id="btnReset">리셋</button>
      </div>
      <div id="scoreline" class="muted" style="margin-top:8px; display:none;"></div>
    </section>

    <ol id="quizList" style="margin-top:12px;"></ol>

    <footer>
      • 각 문제는 정답 채점과 해설을 제공합니다. OX/객관식/단답/서술형 혼합.
    </footer>
  </main>

  <script>
  const DEFAULT_QUIZ = [
    { id:1, type:"short", question:"결정 트리는 어떤 두 가지 문제 유형에 모두 활용되는가?", acceptable:["분류와 회귀"], explanation:"지도학습에서 분류(Classification)·회귀(Regression) 모두 사용." },
    { id:2, type:"short", question:"결정 트리의 최종 예측 노드를 무엇이라 하는가?", acceptable:["리프 노드","단말 노드"], explanation:"리프(단말) 노드는 더 이상 분할하지 않고 최종 예측을 나타냅니다." },
    { id:3, type:"short", question:"결정 트리에서 데이터를 반복 분할하는 전략은?", acceptable:["분할 정복","divide and conquer"], explanation:"데이터를 작은 부분으로 나누어 정복하는 전략." },
    { id:4, type:"ox", question:"지니 불순도가 0이면 해당 노드는 완전 순수 상태다. (O/X)", answer:"O", explanation:"모든 샘플이 동일 클래스면 지니=0." },
    { id:5, type:"short", question:"속성 중요도는 어떤 기준으로 계산되는가?", acceptable:["불순도 감소","지니 중요도"], explanation:"트리 분할 시 불순도 감소량을 누적." },
    { id:6, type:"short", question:"결정 트리가 훈련 데이터의 작은 변화에도 크게 달라지는 성질을 무엇이라 하는가?", acceptable:["높은 분산"], explanation:"트리의 불안정성 → 높은 분산 문제." },
    { id:7, type:"short", question:"트리의 복잡도를 줄여 과적합을 방지하는 대표 방법은?", acceptable:["가지치기","pruning"], explanation:"사전/사후 가지치기로 트리 크기 제한." },
    { id:8, type:"short", question:"여러 트리를 결합하여 단일 트리의 한계를 극복하는 방법은?", acceptable:["앙상블"], explanation:"랜덤 포레스트, AdaBoost 등 앙상블 기법." },
    { id:9, type:"short", question:"랜덤 포레스트의 두 가지 핵심 아이디어는?", acceptable:["배깅과 무작위 특성 선택"], explanation:"부트스트랩 샘플링+특성 랜덤 선택." },
    { id:10, type:"ox", question:"랜덤 포레스트에서 분류 문제의 최종 결과는 다수결 투표 방식이다. (O/X)", answer:"O", explanation:"분류는 다수결, 회귀는 평균." },
    { id:11, type:"short", question:"랜덤 포레스트가 제공하는 점수로 각 특성의 기여도를 보여주는 것은?", acceptable:["특성 중요도"], explanation:"feature importance 제공." },
    { id:12, type:"short", question:"AdaBoost에서 여러 개의 ( ) 학습기를 순차적으로 학습시켜 오류를 보완한다.", acceptable:["약한"], explanation:"약한 학습기를 직렬로 학습." },
    { id:13, type:"ox", question:"AdaBoost에서는 잘못 분류된 샘플의 가중치가 다음 라운드에서 증가한다. (O/X)", answer:"O", explanation:"오분류 샘플에 집중 학습." },
    { id:14, type:"short", question:"AdaBoost의 단점 중 하나는 무엇인가?", acceptable:["노이즈에 민감","이상치에 민감"], explanation:"노이즈, 이상치에 취약." },
    { id:15, type:"short", question:"차원의 저주(Curse of Dimensionality)란?", acceptable:["특성이 증가할수록 데이터 희소"], explanation:"차원 증가 → 데이터 희소·과적합·계산량 증가." },
    { id:16, type:"ox", question:"차원 축소의 주요 목적 중 하나는 시각화를 가능하게 하는 것이다. (O/X)", answer:"O", explanation:"2D/3D 투영 가능." },
    { id:17, type:"short", question:"PCA에서 첫 번째 주성분은 데이터의 무엇이 가장 큰 방향인가?", acceptable:["분산"], explanation:"첫 번째 PC는 분산이 최대인 방향." },
    { id:18, type:"short", question:"PCA에서 주성분의 방향을 나타내는 것은 무엇인가?", acceptable:["고유벡터"], explanation:"고유벡터=방향, 고유값=설명력." },
    { id:19, type:"short", question:"PCA의 단점 중 하나는 ( ) 구조를 잘 포착하지 못한다는 점이다.", acceptable:["비선형"], explanation:"PCA는 선형 차원 축소 기법." },
    { id:20, type:"short", question:"t-SNE와 UMAP 중 UMAP의 장점 두 가지를 적어라.", acceptable:["빠른 속도","전역 구조 보존"], explanation:"UMAP은 빠르고 전역/지역 구조 모두 보존." }
  ];

  let quiz = DEFAULT_QUIZ;
  let answers = {};
  let results = {};
  let gradedAll = false;

  const $ = (s)=>document.querySelector(s);

  function setStat() {
    $('#count').textContent = quiz.length;
    const done = Object.values(results).filter(Boolean).length;
    $('#graded').textContent = `${done} / ${quiz.length}`;
    if (gradedAll) {
      const correct = Object.values(results).filter(r => r && r.correct).length;
      const pct = quiz.length ? Math.round((correct/quiz.length)*100) : 0;
      $('#scoreline').textContent = `점수: ${correct} / ${quiz.length} (${pct}%)`;
      $('#scoreline').style.display = 'block';
    } else {
      $('#scoreline').style.display = 'none';
    }
  }

  function norm(s){return (s??'').toString().trim().toLowerCase();}

  function checkOne(item,user){
    if(item.type==="ox"){
      const correct = norm(user)===norm(item.answer);
      return {correct, feedback: correct?"정답":`정답은 ${item.answer}`};
    }
    if(item.acceptable){
      const acc=item.acceptable.map(norm);
      const correct=acc.some(a=>norm(user)===a||norm(user).includes(a));
      return {correct, feedback: correct?"정답":`예시 정답: ${item.acceptable[0]}`};
    }
    return {correct:false, feedback:""};
  }

  function render(){
    const list=$('#quizList'); list.innerHTML='';
    quiz.forEach(item=>{
      const li=document.createElement('li'); li.className='card';
      const q=document.createElement('p'); q.className='q'; q.textContent=`${item.id}. ${item.question}`; li.appendChild(q);
      let inputEl;
      if(item.type==="ox"){
        inputEl=document.createElement('select');
        inputEl.innerHTML='<option value="">선택</option><option>O</option><option>X</option>';
      } else {
        inputEl=document.createElement('textarea');
        inputEl.rows=2; inputEl.placeholder="답 입력";
      }
      inputEl.value=answers[item.id]??'';
      inputEl.addEventListener('input',e=>{answers[item.id]=e.target.value; results[item.id]=undefined; gradedAll=false; setStat(); renderRowFooter(li,item);});
      li.appendChild(inputEl);
      const row=document.createElement('div'); row.className='row'; row.style.marginTop='8px';
      const btn=document.createElement('button'); btn.textContent='채점';
      btn.onclick=()=>{results[item.id]=checkOne(item,answers[item.id]); renderRowFooter(li,item); setStat();};
      row.appendChild(btn);
      const badge=document.createElement('span'); badge.id=`badge-${item.id}`; badge.className='badge'; badge.style.display='none'; row.appendChild(badge);
      li.appendChild(row);
      const fb=document.createElement('div'); fb.id=`fb-${item.id}`; fb.style.marginTop='8px'; li.appendChild(fb);
      list.appendChild(li);
      renderRowFooter(li,item);
    });
    setStat();
  }

  function renderRowFooter(li,item){
    const r=results[item.id]; const badge=li.querySelector(`#badge-${item.id}`); const fb=li.querySelector(`#fb-${item.id}`);
    if(r){ badge.style.display='inline-block'; badge.textContent=r.correct?'정답':'오답'; badge.className=`badge ${r.correct?'ok':'bad'}`;
      fb.innerHTML=`<p class="muted"><strong>피드백:</strong> ${r.feedback}</p><details><summary>해설 보기</summary><div class="card" style="margin-top:6px;">${item.explanation}</div></details>`;
    } else { badge.style.display='none'; fb.innerHTML=''; }
  }

  $('#btnGradeAll').onclick=()=>{results={}; quiz.forEach(q=>{results[q.id]=checkOne(q,answers[q.id]);}); gradedAll=true; render();};
  $('#btnReset').onclick=()=>{answers={}; results={}; gradedAll=false; render();};
  $('#btnDefault').onclick=()=>{quiz=DEFAULT_QUIZ; answers={}; results={}; gradedAll=false; render();};

  render();
  </script>
</body>
</html>
